#ifndef TEXT_LINE_MAX
#define TEXT_LINE_MAX         800
#endif


#ifndef     PI
#define     PI                3.14159265358979323846
#define     PI_180            0.01745329252
#endif

#define BLOCKDIM 1024
#define BLOCKDIMX  32
#define BLOCKDIMY  32
#define GRIDDIMX  4

#define SIZELIMIT 2500

#include <stdio.h>
#include <string.h>
#include <time.h>
#include <cuda_runtime_api.h>
#include "mrcfile3.h"
#include "../log/log.h"
#include "cufft.h"

void help()
{
    printf("ICONMask3 parameter\n######\n");
    printf("-inputPath (-i) : the folder that contains all 2D reconstructed slices (named midxxxxx.mrc), normally corresponding to the reconstruction folder generated by ICON.\n######\n");
    printf("-tiltfile (-t) : the aligned tilt file.\n######\n");
    printf("-output (-o) : the masked 3D reconstruction.\n######\n");
    printf("-slice (-s) : the reconstructed slices for combination including 2 parts split by ','. For example, 0,511 means that combining 512 slices ranging from slice 0 (mid00000.mrc) to slice 511 (mid00511.mrc).\n######\n");
    printf("-thikness (-th) : the thickness of the final masked 3D reconstruction in pixel.\n######\n");
    printf("-radius (-r) : the mask radius (in pixel) used in the Fourier domain of the combined 3D reconstruction. If this option is used, 'crossVfrc' and 'fullRecfrc' are not used.\n######\n");
    printf("-gaussWidth (-gw) : the gaussian width of the soft mask (in pixel). If '-crossVfrc' & '-fullRecVfrc' are used, the default value is calculated accroding to FRC0.3 - FRC0.5; if '-radius' is used, the default value is 10.\n######\n");
    printf("-crossVfrc (-cf) : the FRC curve from the cross validation process. If 'radius' is used, this option is not used.\n######\n");
    printf("-fullRecfrc (-ff) : the FRC file from the full reconstruction process. If 'radius' is used, this option is not used.\n######\n");
    printf("-zshift (-z) : the shift (in pixel) of sample in Z axis, default as 0.\n#####\n");
    printf("-nomask (-nm) : if this value is set to 0 then a validation filtering mask will be executed; otherwise, no validation filtering mask will be executed, default as 0.\n######\n");
    printf("-help (-h) : for help.\n");
}

void simpleCatch(char *infilePath,int sliceBegin,int sliceEnd,int thickness,char *outfile,int zshift)
{
    char loginfo[1000];
    MrcHeader  *outhead;
    FILE  *fout;
    if((fout=fopen(outfile,"w+"))==NULL)
    {
        printf("\nCannot open file '%s' strike any key exit!",outfile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Cannot open file '%s'\n",outfile);
        logwrite(loginfo);
        //end of log Write
        exit(1);
    }
    outhead=(MrcHeader *)malloc(sizeof(MrcHeader));

    // MRCCatch
    float *indataD;
    //float *indatatmp;
    int nx;
    long ii,j;
    int i;
    MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    FILE * infile;
    char filename[1000];
    float finishedTask = 0;
    int processedNum;
    float totalTask = sliceEnd - sliceBegin + 1;
    int processFactor = 5;
    int pp;
    char processedcmd[1000];
    double amean,amin,amax;
    float tmp;
    amean = 0.0;
    amin = 10e10;
    amax = -10e10;
    for (i = sliceBegin ; i <= sliceEnd; i++)
    {
        sprintf(filename,"%s/mid%05d.mrc",infilePath,i);
        if ((infile = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Cannot open infile '%s'\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(infile,inhead);
        if (zshift < 0)
        {
            if (inhead->ny/2-zshift+thickness/2 > inhead->ny)
            {
                printf("zshift & thickness make the size of volume out of limitation!\n");
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"zshift & thickness make the size of volume out of limitation!\n");
                logwrite(loginfo);
                //end of log Write
                exit(0);
            }
        }
        else
        {
            if (inhead->ny/2-zshift-thickness/2 < 0)
            {
                printf("zshift & thickness make the size of volume out of limitation!\n");
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"zshift & thickness make the size of volume out of limitation!\n");
                logwrite(loginfo);
                //end of log Write
                exit(0);
            }
        }
        if (i == sliceBegin)
        {
            //indatatmp = (float *)malloc((long)inhead->nx*(long)inhead->ny*sizeof(float));
            indataD = (float *)malloc((long)inhead->nx*(long)thickness*sizeof(float));
            nx = inhead->nx;
            memcpy(outhead,inhead,sizeof(MrcHeader));
            //mrc_init_head(outhead);
            outhead->nx = nx;
            outhead->ny = thickness;
            outhead->nz = (sliceEnd-sliceBegin+1);
            outhead->mode = MRC_MODE_FLOAT;
            mrc_write_head(fout,outhead);
        }
	long ystart = inhead->ny/2 - thickness/2 + zshift, yend = ystart + thickness;
        //mrc_read_slice(infile,inhead,0,'z',indatatmp);
	mrc_read_slice_in_Z_with_thickness(infile,inhead,0,'z',indataD,ystart,yend);
	//calculate mean, max and min for the final volume.
        for (j = 0; j < yend-ystart ; j++)
        	for (ii = 0 ; ii < nx ; ii++){
			tmp = indataD[j*nx+ii];
			if (tmp > amax)
				amax = tmp;
			if (tmp < amin)
				amin = tmp;
			amean += tmp;
	}
	//end of calculate mean, max and min for the final volume.
        //mrc_add_slice(fout,outhead,indatatmp+ystart*nx);
	mrc_add_slice(fout,outhead,indataD);
        fclose(infile);
        finishedTask+=1;
        processedNum = (int)(finishedTask/totalTask*100/processFactor);
        for (pp = 0; pp < processedNum; pp++)
            processedcmd[pp] = '.';
        processedcmd[processedNum] = '>';
        for (pp = processedNum+1; pp < 100/processFactor; pp++)
            processedcmd[pp] = ' ';
        processedcmd[pp] = '\0';
        printf("simple catched %.2f%%",finishedTask/totalTask*100);
        printf("  #%s",processedcmd);
        printf("#\r");
        fflush(stdout);
    }

    fclose(fout);

    //update output header 
    outhead->amin = amin;
    outhead->amax = amax;
    outhead->amean = amean/outhead->nz/outhead->nx/outhead->ny;
    mrc_replace_head(outfile,outhead);
    mrc_update_rms(outfile);
	
    //mrc_update_head(outfile);

    //free(indatatmp);
    free(indataD);
    free(outhead);
                                                            
    //log Write
    sprintf(loginfo,"running state:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"ICONMask3 simple catch finish!\n");
    logwrite(loginfo);
    //end of log Write
}

/*void maskSlice(float* indataD,int Sx,float* origmask,float radius05Rate,float radius03Rate,int paraMark3,fftwf_complex* indataft,fftwf_plan *p,fftwf_plan *pinv,int paraMark9,int gaussWidth,int printfMark)
{
    int radius05 = (int)((float)Sx/2.0*radius05Rate);
    int radius03 = (int)((float)Sx/2.0*radius03Rate);
    int nx,ny,i,j,i1,j1;
    nx = ny = Sx;

    fftwf_execute(*p);

    double w,w2;

    long gaussianlenMax;
    int radius;
    if (!paraMark3)
    {
        if (!paraMark9)
            gaussianlenMax = radius03-radius05;
        else
            gaussianlenMax = gaussWidth;
        radius = radius05;
    }
    else
    {
        radius = radius05;
        if (!paraMark9)
            gaussianlenMax = 10.0*(Sx/150.0);
        else
            gaussianlenMax = gaussWidth;
    }
    if (gaussianlenMax < 10.0*(Sx/150.0))
        gaussianlenMax = 10.0*(Sx/150.0);

    if (!paraMark9 && printfMark)
        printf("gaussWidth : %ld\n",gaussianlenMax);
    long gaussianradius = (radius + gaussianlenMax);
    long gaussianlen = gaussianradius - radius;

    long rr;
    double xxx,c;
    c = (double)gaussianlen/3.0;
    for (j = 0 ; j < ny ; j++)
        for (i = 0 ; i < nx/2+1 ; i++)
        {
                i1 = (i + nx/2)%nx;
                j1 = (j + ny/2)%ny;
                rr = sqrt((i1-nx/2)*(i1-nx/2)+(j1-ny/2)*(j1-ny/2));
                if (rr >= radius)
                {
                    if (rr <= gaussianradius)
                    {
                        w = origmask[j1*nx+i1];
                        xxx = rr - radius;
                        w2 = (exp(-(xxx*xxx)/(2*c*c))-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)))/(1-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)));
                        w = w > w2 ? w : w2;
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                    else
                    {
                        w = origmask[j1*nx+i1];
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                }
         }

    fftwf_execute(*pinv);

    double factor = (double)nx*(double)ny;
    long len = (long)nx*(long)ny;
    for (i = 0 ; i < len ; i++)
        indataD[i] /= factor;
}*/

/*void maskAndWeightSlice(float* indataD,int Sx,float* origmask,float radius05Rate,float radius03Rate,int paraMark3,fftwf_complex* indataft,fftwf_plan *p,fftwf_plan *pinv,int paraMark9,int gaussWidth,int printfMark,float MaxAngDif,int AngNum)
{

    //calculate r_full
    int r_full = ceil(AngNum/(MaxAngDif/360.0*2*3.1415926));



    int radius05 = (int)((float)Sx/2.0*radius05Rate);
    int radius03 = (int)((float)Sx/2.0*radius03Rate);
    int nx,ny,i,j,i1,j1;
    nx = ny = Sx;

    fftwf_execute(*p);

    double w,w2;

    long gaussianlenMax;
    int radius;
    if (!paraMark3)
    {
        if (!paraMark9)
            gaussianlenMax = radius03-radius05;
        else
            gaussianlenMax = gaussWidth;
        radius = radius05;
    }
    else
    {
        radius = radius05;
        if (!paraMark9)
            gaussianlenMax = 10.0*(Sx/150.0);
        else
            gaussianlenMax = gaussWidth;
    }
    if (gaussianlenMax < 10.0*(Sx/150.0))
        gaussianlenMax = 10.0*(Sx/150.0);

    if (!paraMark9 && printfMark)
        printf("gaussWidth : %ld\n",gaussianlenMax);
    long gaussianradius = (radius + gaussianlenMax);
    long gaussianlen = gaussianradius - radius;

    long rr;
    double xxx,c;
    c = (double)gaussianlen/3.0;
    for (j = 0 ; j < ny ; j++)
        for (i = 0 ; i < nx/2+1 ; i++)
        {
                i1 = (i + nx/2)%nx;
                j1 = (j + ny/2)%ny;
                rr = sqrt((i1-nx/2)*(i1-nx/2)+(j1-ny/2)*(j1-ny/2));

		//crossValidation mask
                if (rr >= radius)
                {
                    if (rr <= gaussianradius)
                    {
                        w = origmask[j1*nx+i1];
                        xxx = rr - radius;
                        w2 = (exp(-(xxx*xxx)/(2*c*c))-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)))/(1-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)));
                        w = w > w2 ? w : w2;
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                    else
                    {
                        w = origmask[j1*nx+i1];
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                }
		
		//weight
		if (rr > r_full){
			indataft[j*(nx/2+1)+i][0] *= (float)rr/(float)r_full;
			indataft[j*(nx/2+1)+i][1] *= (float)rr/(float)r_full;
		} 
         }

    fftwf_execute(*pinv);

    double factor = (double)nx*(double)ny;
    long len = (long)nx*(long)ny;
    for (i = 0 ; i < len ; i++)
        indataD[i] /= factor;
}*/

void genMask(float* indataD,int Sx,float* origmask,float radius05Rate,float radius03Rate,int paraMark3,int paraMark9,int gaussWidth,int printfMark,float meanAngDif,int AngNum,float* realMask,float* weighting)
{

    //calculate r_full
    int r_full = ceil(2.0/(meanAngDif/360.0*2*3.1415926));
    //printf("r_full %d meanAngDif %f\n",r_full,meanAngDif);


    int radius05 = (int)((float)Sx/2.0*radius05Rate);
    int radius03 = (int)((float)Sx/2.0*radius03Rate);
    int nx,ny,i,j,i1,j1;
    nx = ny = Sx;

    //fftwf_execute(*p);

    double w,w2;

    long gaussianlenMax;
    int radius;
    if (!paraMark3)
    {
        if (!paraMark9)
            gaussianlenMax = radius03-radius05;
        else
            gaussianlenMax = gaussWidth;
        radius = radius05;
    }
    else
    {
        radius = radius05;
        if (!paraMark9)
            gaussianlenMax = 10.0*(Sx/150.0);
        else
            gaussianlenMax = gaussWidth;
    }
    if (gaussianlenMax < 10.0*(Sx/150.0))
        gaussianlenMax = 10.0*(Sx/150.0);

    /*if (!paraMark9 && printfMark)
        printf("gaussWidth : %ld\n",gaussianlenMax);*/
    long gaussianradius = (radius + gaussianlenMax);
    long gaussianlen = gaussianradius - radius;

    long rr;
    double xxx,c;
    c = (double)gaussianlen/3.0;
    for (j = 0 ; j < ny ; j++)
        for (i = 0 ; i < nx/2+1 ; i++)
        {
                i1 = (i + nx/2)%nx;
                j1 = (j + ny/2)%ny;
                rr = sqrt((i1-nx/2)*(i1-nx/2)+(j1-ny/2)*(j1-ny/2));

		//crossValidation mask
                if (rr >= radius)
                {
                    if (rr <= gaussianradius)
                    {
                        w = origmask[j1*nx+i1];
                        xxx = rr - radius;
                        w2 = (exp(-(xxx*xxx)/(2*c*c))-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)))/(1-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)));
                        w = w > w2 ? w : w2;
			realMask[j*(nx/2+1)+i] = w;
                    }
                    else
                    {
                        w = origmask[j1*nx+i1];
                        realMask[j*(nx/2+1)+i] = w;
                    }
                }
		else
			realMask[j*(nx/2+1)+i] = 1.0;
		
		//weight only on sampled area
		if (rr > r_full && fabs(origmask[j1*nx+i1]) > 0.00001){
			weighting[j*(nx/2+1)+i] = (float)rr/(float)r_full;
		} 
		else
			weighting[j*(nx/2+1)+i] = 1.0;
         }

    //fftwf_execute(*pinv);

    /*double factor = (double)nx*(double)ny;
    long len = (long)nx*(long)ny;
    for (i = 0 ; i < len ; i++)
        indataD[i] /= factor;*/
}

__global__ void weightAndMaskFuncCU(cufftComplex* indataft,float *origmask,int ny,int nx,long gaussianradius,long gaussianlen,int radius,int r_full,float *realMaskCU,float *weightingCU){
    int j = blockIdx.x+blockIdx.y*gridDim.x;
    int i = threadIdx.x+threadIdx.y*blockDim.x;
    int pn = i + j*(blockDim.x*blockDim.y);
    if (pn < ny*(nx/2+1)){
	//crossValidation mask 
	float tmp = realMaskCU[pn]*weightingCU[pn];              
	indataft[pn].x *= tmp;
        indataft[pn].y *= tmp;
    }
}

__global__ void divideCU(float* indataD,double factor,long size){
    int blockid = blockIdx.x+blockIdx.y*gridDim.x;
    int threadid = threadIdx.x+threadIdx.y*blockDim.x;
    int pn = threadid + blockid*(blockDim.x*blockDim.y);
    if (pn < size){
	indataD[pn] /= factor;
    }
}

void maskAndWeightSliceCU(float* indataDCU,int Sx,float* origmaskCU,float radius05Rate,float radius03Rate,int paraMark3,cufftComplex* indataftCU,cufftHandle p_R2C,cufftHandle p_C2R,int paraMark9,int gaussWidth,int printfMark,float meanAngDif,int AngNum,float *realMaskCU,float *weightingCU)
{

    //calculate r_full
    int r_full = ceil(2.0/(meanAngDif/360.0*2*3.1415926));



    int radius05 = (int)((float)Sx/2.0*radius05Rate);
    int radius03 = (int)((float)Sx/2.0*radius03Rate);
    int nx,ny;
    nx = ny = Sx;

    //fftwf_execute(*p);
    cufftExecR2C(p_R2C,indataDCU,indataftCU);

    /*{
    cufftComplex *f2 = (cufftComplex*)malloc(sizeof(cufftComplex)*Sx*Sx);
    cudaMemcpy(f2,indataftCU,sizeof(cufftComplex)*Sx*Sx, cudaMemcpyDeviceToHost);
    for (int ii = 0 ; ii < 10 ; ii++)
	printf("####%f %f\n",f2[ii].x,f2[ii].y);
    FILE *f = fopen("cu_mark1","w+");
    for (int ii = 0 ; ii < (Sx/2+1)*Sx ; ii+=1)
	fprintf(f,"%f %f\n",f2[ii].x,f2[ii].y);
    fclose(f);
    free(f2);
    }*/

    long gaussianlenMax;
    int radius;
    if (!paraMark3)
    {
        if (!paraMark9)
            gaussianlenMax = radius03-radius05;
        else
            gaussianlenMax = gaussWidth;
        radius = radius05;
    }
    else
    {
        radius = radius05;
        if (!paraMark9)
            gaussianlenMax = 10.0*(Sx/150.0);
        else
            gaussianlenMax = gaussWidth;
    }
    if (gaussianlenMax < 10.0*(Sx/150.0))
        gaussianlenMax = 10.0*(Sx/150.0);

    if (!paraMark9 && printfMark)
        printf("gaussWidth : %ld\n",gaussianlenMax);
    long gaussianradius = (radius + gaussianlenMax);
    long gaussianlen = gaussianradius - radius;

    /*long rr;
    double xxx,c;
    c = (double)gaussianlen/3.0;
    for (j = 0 ; j < ny ; j++)
        for (i = 0 ; i < nx/2+1 ; i++)
        {
                i1 = (i + nx/2)%nx;
                j1 = (j + ny/2)%ny;
                rr = sqrt((i1-nx/2)*(i1-nx/2)+(j1-ny/2)*(j1-ny/2));

		//crossValidation mask
                if (rr >= radius)
                {
                    if (rr <= gaussianradius)
                    {
                        w = origmask[j1*nx+i1];
                        xxx = rr - radius;
                        w2 = (exp(-(xxx*xxx)/(2*c*c))-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)))/(1-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)));
                        w = w > w2 ? w : w2;
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                    else
                    {
                        w = origmask[j1*nx+i1];
                        indataft[j*(nx/2+1)+i][0] *= w;
                        indataft[j*(nx/2+1)+i][1] *= w;
                    }
                }
		
		//weight
		if (rr > r_full){
			indataft[j*(nx/2+1)+i][0] *= (float)rr/(float)r_full;
			indataft[j*(nx/2+1)+i][1] *= (float)rr/(float)r_full;
		} 
         }
    */
    weightAndMaskFuncCU<<<dim3(GRIDDIMX,((ny*(nx/2+1) - 1)/BLOCKDIM)/GRIDDIMX+1),dim3(BLOCKDIMX,BLOCKDIMY)>>>(indataftCU,origmaskCU,ny,nx,gaussianradius,gaussianlen,radius,r_full,realMaskCU,weightingCU);

    /*{
    cufftComplex *f2 = (cufftComplex*)malloc(sizeof(cufftComplex)*Sx*Sx);
    cudaMemcpy(f2,indataftCU,sizeof(cufftComplex)*Sx*Sx, cudaMemcpyDeviceToHost);
    for (int ii = 1 ; ii < 10*Sx ; ii+=Sx)
	printf("####22%f %f\n",f2[ii].x,f2[ii].y);
    FILE *f = fopen("cu_mark","w+");
    for (int ii = 0 ; ii < (Sx/2+1)*Sx ; ii+=1)
	fprintf(f,"%f %f\n",f2[ii].x,f2[ii].y);
    fclose(f);
    free(f2);
    }*/

    //fftwf_execute(*pinv);
    cufftExecC2R(p_C2R,indataftCU,indataDCU);

    /*{
    float *f2 = (float*)malloc(sizeof(float)*Sx*Sx);
    cudaMemcpy(f2,indataDCU,sizeof(float)*Sx*Sx, cudaMemcpyDeviceToHost);
    for (int ii = 1 ; ii < 10*Sx ; ii+=Sx)
	printf("####33%f\n",f2[ii]);
    free(f2);
    }*/

    double factor = (double)nx*(double)ny;
    long len = (long)nx*(long)ny;
    divideCU<<<dim3(GRIDDIMX,((len - 1)/BLOCKDIM)/GRIDDIMX+1),dim3(BLOCKDIMX,BLOCKDIMY)>>>(indataDCU,factor,len);
}



int main(int argc,char *argv[])
{
    char infilePath[1000],anglefile[1000],outfile[1000],crossVfrcfile[1000],fullRecfrcfile[1000];
    int radius,radius05,radius03,sliceBegin,sliceEnd,thickness,zshift,gaussWidth,noMask;

    int i,j,k;
    char loginfo[1000];
    time_t rawtime;
    struct tm * timeinfo;
    //log Write
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    logwrite("##############################\n");
    sprintf(loginfo,"time:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"%s",asctime(timeinfo));
    logwrite(loginfo);
    sprintf(loginfo,"cmd:\n   ");
    logwrite(loginfo);
    for (i = 0 ; i < argc ; i++)
    {
        sprintf(loginfo,"%s ",argv[i]);
        logwrite(loginfo);
    }
    sprintf(loginfo,"\n");
    logwrite(loginfo);
    //end of log Write


    // read Parameter

    int paraNum = 11;
    int *paraMark = (int *)malloc(paraNum*sizeof(int));
    i = 1;
    memset(paraMark,0,paraNum*sizeof(int));
    zshift = 0;
    radius = 0;
    paraMark[8] = 1;
    noMask = 0;
    while (i < argc)
    {
        if (argv[i][0] == '-')
        {
            if (strcmp(argv[i]+1,"inputPath") == 0 || strcmp(argv[i]+1,"i") == 0)
            {
                i++;
                sscanf(argv[i],"%s",infilePath);
                i++;
                paraMark[0] = 1;
            }
            else if (strcmp(argv[i]+1,"slice") == 0 || strcmp(argv[i]+1,"s") == 0)
            {
                i++;
                sscanf(argv[i],"%d,%d",&sliceBegin,&sliceEnd);
                i++;
                paraMark[1] = 1;
            }
            else if (strcmp(argv[i]+1,"thickness") == 0 || strcmp(argv[i]+1,"th") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&thickness);
                i++;
                paraMark[2] = 1;
            }
            else if (strcmp(argv[i]+1,"radius") == 0 || strcmp(argv[i]+1,"r") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&radius);
                i++;
                paraMark[3] = 1;
            }
            else if (strcmp(argv[i]+1,"tiltfile") == 0 || strcmp(argv[i]+1,"t") == 0)
            {
                i++;
                sscanf(argv[i],"%s",anglefile);
                i++;
                paraMark[4] = 1;
            }
            else if (strcmp(argv[i]+1,"output") == 0 || strcmp(argv[i]+1,"o") == 0)
            {
                i++;
                sscanf(argv[i],"%s",outfile);
                i++;
                paraMark[5] = 1;
            }
            else if (strcmp(argv[i]+1,"crossVfrc") == 0 || strcmp(argv[i]+1,"cf") == 0)
            {
                i++;
                sscanf(argv[i],"%s",crossVfrcfile);
                i++;
                paraMark[6] = 1;
            }
            else if (strcmp(argv[i]+1,"fullRecfrc") == 0 || strcmp(argv[i]+1,"ff") == 0)
            {
                i++;
                sscanf(argv[i],"%s",fullRecfrcfile);
                i++;
                paraMark[7] = 1;
            }
            else if (strcmp(argv[i]+1,"zshift") == 0 || strcmp(argv[i]+1,"z") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&zshift);
                i++;
                paraMark[8] = 1;
            }
            else if (strcmp(argv[i]+1,"gaussWidth") == 0 || strcmp(argv[i]+1,"gw") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&gaussWidth);
                i++;
                paraMark[9] = 1;
            }
            else if (strcmp(argv[i]+1,"noMask") == 0 || strcmp(argv[i]+1,"nm") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&noMask);
                i++;
                paraMark[10] = 1;
            }
            else if (strcmp(argv[i]+1,"help") == 0 || strcmp(argv[i]+1,"h") == 0)
            {
                i++;
                help();
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"ICONMask3 help finish!\n");
                logwrite(loginfo);
                //end of log Write
                return 1;
            }
            else
                i++;
        }
        else
            i++;
    }

    {
        printf("parameter:\n");
        printf("inputPath : %s\n",infilePath);
        printf("slice : %d,%d\n",sliceBegin,sliceEnd);
        printf("thickness : %d\n",thickness);
        if (paraMark[3])
            printf("radius : %d\n",radius);
        printf("zshift : %d\n",zshift);
        printf("tiltfile : %s\n",anglefile);
        printf("output : %s\n",outfile);
        if (!paraMark[3] && (paraMark[6] && paraMark[7]))
        {
            printf("crossVfrc : %s\n",crossVfrcfile);
            printf("fullRecfrc : %s\n",fullRecfrcfile);
        }
        if (paraMark[9])
            printf("gaussWidth : %d\n",gaussWidth);
        printf("noMask : %d\n",noMask);
    }

    if (!(paraMark[0] && paraMark[1] && paraMark[2] && paraMark[4] && paraMark[5]))
    {
        printf("parameter error!\n'-inputPath' or '-slice' or '-thickness' or '-tiltfile' or '-output' are missed!\nPlease use -help to see the manual\n");
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"parameter error!\n'-inputPath' or '-slice' or '-thickness' or '-tiltfile' or '-output' are missed!\n");
        logwrite(loginfo);
        //end of log Write
        return -1;
    }

    if (noMask == 1)
    {
        printf("'-noMask' is 1; simple Catch is executed without validation filtering mask!\n");
        simpleCatch(infilePath,sliceBegin,sliceEnd,thickness,outfile,zshift);
        //log write in simpleCatch
        return 1;
    }

    if (noMask == 0 && !paraMark[3] && !(paraMark[6] && paraMark[7]))
    {
        printf("parameter error!\n'-radius' or ('-crossVfrc' & 'fullRecfrc') are missed!\nPlease use -help to see the manual\n");
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"parameter error!\n'-radius' or ('-crossVfrc' & 'fullRecfrc') are missed!\n");
        logwrite(loginfo);
        //end of log Write
        return -1;
    }

    //----------------------------------------------------------end of read Parameter

    //read anglefile
    char *lstr, *pch;
    lstr = (char *)malloc(TEXT_LINE_MAX);
    FILE   *fang;
    float *thita;
    thita = (float *)malloc(360*sizeof(float));
    int  ANG_NUM;

    if((fang=fopen(anglefile,"r"))==NULL)
    {
        printf("\nCannot open file %s strike any key exit!\n",anglefile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Can not open file %s!\n",anglefile);
        logwrite(loginfo);
        //end of log Write
        return -1;
    }

    for(i=0; feof(fang)==0;)
    {
        memset(lstr,0,TEXT_LINE_MAX);
        fgets(lstr,TEXT_LINE_MAX,fang);

        pch = strtok(lstr," ;,\n\r\t");

        if(*lstr==EOF||pch == NULL||strncasecmp(pch,"END",3)==0 )break;

        while(pch != NULL)
        {
            thita[i++] = atof(pch);
            pch = strtok(NULL," ;,\n\r\t");
        }

    }
    free(lstr);
    fclose(fang);
    ANG_NUM = i;
    //--------------------------end of read anglefile

    //calculate the biggest angular step and the radius of missing-wedge that can be filled
    float biggestThita = -1;
    float smallestThita = 1;
    float biggestAngularStep;
    int biggestAngularStepRadius;
    for (i = 0 ; i < ANG_NUM ; i++){
 	if (biggestThita < thita[i])
		biggestThita = thita[i];
	if (smallestThita > thita[i])
		smallestThita = thita[i];
    }
    biggestAngularStep = biggestThita - smallestThita;
    biggestAngularStepRadius = ceil(2*180.0/3.1415926/biggestAngularStep);
    //--------------------------end of calculate the biggest angular step and the radius of missing-wedge that can be filled

    //calculate the mean angular step 
    float meanAngularStep = 0.0;
    for (i = 0 ; i < ANG_NUM-1 ; i++){
 	meanAngularStep += fabs(thita[i+1] - thita[i]);
    }

    meanAngularStep  /= ANG_NUM-1;
    //--------------------------end of calculate the mean angular step 


    int Sx,Sy;
    //get mask parameters
    {
        MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
        FILE * fin;
        char filename[1000];
        sprintf(filename,"%s/mid%05d.mrc",infilePath,sliceBegin);
        if ((fin = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open infile %s!\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(fin,inhead);
        Sx = inhead->nx;
        Sy = inhead->ny;
	fclose(fin);
        free(inhead);
    }

    //calculate the radius of mask
    float radius05Rate,radius03Rate;
    int frcValidMark = 1;
    if (!paraMark[3])
    {
        FILE *fcrossVfrc,*ffullRecfrc;
        if((fcrossVfrc=fopen(crossVfrcfile,"r"))==NULL)
        {
            printf("\nCannot open file '%s' strike any key exit!",crossVfrcfile);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open file %s!\n",crossVfrcfile);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        if((ffullRecfrc=fopen(fullRecfrcfile,"r"))==NULL)
        {
            printf("\nCannot open file '%s' strike any key exit!",fullRecfrcfile);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open file %s!\n",fullRecfrcfile);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        int frcsize = 0;
        float tmp;
        float crossVfrc[10000],fullRecfrc[10000];
        while (fscanf(fcrossVfrc,"%f %f",&tmp,&(crossVfrc[frcsize]))!=EOF)
        {
            frcsize++;
        }
        fclose(fcrossVfrc);
        if (frcsize < Sx/2 - 1)
        {
            printf("'-crossVfrc' %s is not valid\nAssign radius : %d\n",crossVfrcfile,biggestAngularStepRadius);
            paraMark[3] = 1;
	    radius = biggestAngularStepRadius;
	    frcValidMark = 0;
        }
	if (frcValidMark){
            frcsize = 0;
            while (fscanf(ffullRecfrc,"%f %f",&tmp,&(fullRecfrc[frcsize]))!=EOF)
            {
                frcsize++;
            }
            fclose(ffullRecfrc);
            if (frcsize < Sx/2 - 1)
            {
            	printf("'-fullRecfrc' %s is not valid\nAssign radius : %d\n",fullRecfrcfile,biggestAngularStepRadius);
            	paraMark[3] = 1;
	    	radius = biggestAngularStepRadius;
	    	frcValidMark = 0;
            }
	    if (frcValidMark){
            	for (i = 0 ; i < frcsize ; i++)
            		{
            			if (fullRecfrc[i] != 0)
                			crossVfrc[i] /= fullRecfrc[i];
            		}  
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
            		if (crossVfrc[i] >= 0.5)
               			break;
       	    	radius = i;
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
            		if (crossVfrc[i] >= 0.3)
                		break;
            	radius03 = i;
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
             		if (crossVfrc[i] >= 0.5)
                		break;
            	radius05 = i;
            	printf("the calculated radius of frc0.5 is %d\nthe calculated radius of frc0.3 is %d\n",radius05,radius03);
            	if ((radius05>radius03) || radius03 == 0)
            	{
            		printf("(radius05>radius03) || radius03 == 0 means the frc Files are not valid\nAssign radius : %d\n",biggestAngularStepRadius);
            		paraMark[3] = 1;
	    		radius = biggestAngularStepRadius;
	    		frcValidMark = 0;
            	}
		if (frcValidMark){
            		radius05Rate = (float)radius05/(float)frcsize;
            		radius03Rate = (float)radius03/(float)frcsize;
		}
	    }
    	}
    }
    if (paraMark[3])
    {
        radius05Rate = (float)radius/((float)Sx/2.0);
        radius03Rate = 0;
    }
    //--------------------------end of calculate the radius of mask

    //generation of bangbang
    long ny = Sx;
    long nx = Sy;
    float *line = (float *)malloc(nx*ny*sizeof(float));
    float *rotline = (float *)malloc(nx*ny*sizeof(float));
    float *origmask = (float *)malloc(nx*ny*sizeof(float));
    float *realMask = (float *)malloc(sizeof(float)*Sx*Sy);
    float *weighting = (float *)malloc(sizeof(float)*Sx*Sy);
    float xf,yf,dx,dy;
    int xi,yi;
    float costhita,sinthita;
    memset(origmask,0,nx*ny*sizeof(float));
    memset(line,0,nx*ny*sizeof(float));
    for (j = 0 ; j < nx ; j++)
        line[j*nx+nx/2] = 1.0;
    for (k = 0 ; k < ANG_NUM ; k++)
    {
        costhita = cos((-thita[k]-90)*PI_180);
        sinthita = sin((-thita[k]-90)*PI_180);
        memset(rotline,0,nx*ny*sizeof(float));
        for (j = 0 ; j < ny ; j++)
            for (i = 0 ; i < nx ; i++)
            {
                if (line[j*nx+i] != 0)
                {
                    xf = (float)(i-nx/2)*costhita-(float)(j-ny/2)*sinthita+nx/2;
                    yf = (float)(i-nx/2)*sinthita+(float)(j-ny/2)*costhita+ny/2;
                    xi = (int)xf;
                    yi = (int)yf;
                    dx = xf - xi;
                    dy = yf - yi;
                    if (xi >= 0 && xi < nx && yi >=0 && yi <ny)
                        rotline[yi*nx+xi] += line[j*nx+i]*(1-dx)*(1-dy);
                    if (xi >= 0 && xi < nx && yi+1 >=0 && yi+1 <ny)
                        rotline[(yi+1)*nx+xi] += line[j*nx+i]*(1-dx)*dy;
                    if (xi+1 >= 0 && xi+1 < nx && yi >=0 && yi <ny)
                        rotline[yi*nx+xi+1] += line[j*nx+i]*dx*(1-dy);
                    if (xi+1 >= 0 && xi+1 < nx && yi+1 >=0 && yi+1 <ny)
                        rotline[(yi+1)*nx+xi+1] += line[j*nx+i]*dx*dy;
                }
            }
        for (i = 0 ; i < nx*ny ; i++)
        {
            origmask[i] += rotline[i];
        }
    }
    for (i = 0 ; i < nx*ny ; i++)
        if (origmask[i] > 1)
            origmask[i] = 1;

    /*FILE *mf = fopen("mask_In2D","w+");
    for (i = 0 ; i < nx*ny ; i++)
	fprintf(mf,"%f\n",origmask[i]);
    fclose(mf);*/
	

    //end of generation of bangbang


    //mask In 2D
    float *indataD = (float *)malloc(sizeof(float)*Sx*Sy);

    MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    MrcHeader * outhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    FILE * fin,*fout;
    if((fout=fopen(outfile,"w+"))==NULL)
    {
        printf("\nCannot open file '%s' strike any key exit!",outfile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Can not open file %s!\n",outfile);
        logwrite(loginfo);
        //end of log Write
        exit(1);
    }
    {
        char filename[1000];
        sprintf(filename,"%s/mid%05d.mrc",infilePath,sliceBegin);
        if ((fin = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open infile %s!\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(fin,inhead);
        fclose(fin);
    }
    memcpy(outhead,inhead,sizeof(MrcHeader));
    outhead->nx = Sx;
    outhead->nz = sliceEnd - sliceBegin + 1;
    outhead->ny = thickness;
    outhead->mode = MRC_MODE_FLOAT;
    mrc_write_head(fout,outhead);

    char filename[1000];
    int z;
    double amean = 0;
    double amin = 10e10;
    double amax = -10e10;
    float totalTask = outhead->nz;
    float finishedTask = 0;
    char processedcmd[1000];
    int processedNum,pp,processFactor;
    int printfMark = 1;
    processFactor = 5;
    float dataT;  
    int ystart = Sy/2 - thickness/2 + zshift;
    float *indataDCU,*origmaskCU;
    cufftComplex *indataftCU;
    cudaMalloc((void**)&(indataDCU), sizeof(float)*Sx*Sy);
    cudaMalloc((void**)&(origmaskCU), sizeof(float)*Sx*Sy);
    cudaMalloc((void**)&(indataftCU), sizeof(cufftComplex)*Sy*Sx);
    cudaMemcpy(origmaskCU,origmask,sizeof(float)*Sx*Sy, cudaMemcpyHostToDevice);

    genMask(indataD,Sx,origmask,radius05Rate,radius03Rate,paraMark[3],paraMark[9],gaussWidth,printfMark,meanAngularStep,ANG_NUM,realMask,weighting);
    float *realMaskCU,*weightingCU;
    cudaMalloc((void**)&(realMaskCU), sizeof(float)*Sx*Sy);
    cudaMalloc((void**)&(weightingCU), sizeof(float)*Sx*Sy);

    cudaMemcpy(realMaskCU,realMask,sizeof(float)*Sx*Sy, cudaMemcpyHostToDevice);
    cudaMemcpy(weightingCU,weighting,sizeof(float)*Sx*Sy, cudaMemcpyHostToDevice);

    cufftHandle p_R2C,p_C2R;
    cufftPlan2d(&(p_R2C),Sx,Sy,CUFFT_R2C);
    cufftPlan2d(&(p_C2R),Sx,Sy,CUFFT_C2R);
    for (z = sliceBegin ; z <= sliceEnd ; z++){
	sprintf(filename,"%s/mid%05d.mrc",infilePath,z);
	if ((fin = fopen(filename,"r")) == NULL)
        {
                printf("\nCan not open infile %s!\n",filename);
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"Can not open infile %s!\n",filename);
                logwrite(loginfo);
                //end of log Write
                exit(1);
        }
        mrc_read_head(fin,inhead);
	mrc_read_slice(fin,inhead,0,'z',indataD);
        fclose(fin);
        cudaMemcpy(indataDCU,indataD,sizeof(float)*Sx*Sy, cudaMemcpyHostToDevice);        
        //maskSlice(indataD,Sx,origmask,radius05Rate,radius03Rate,paraMark[3],indataft,&p,&pinv,paraMark[9],gaussWidth,printfMark);
	//maskAndWeightSlice(indataD,Sx,origmask,radius05Rate,radius03Rate,paraMark[3],indataft,&p,&pinv,paraMark[9],gaussWidth,printfMark,biggestAngularStep,ANG_NUM);
	maskAndWeightSliceCU(indataDCU,Sx,origmaskCU,radius05Rate,radius03Rate,paraMark[3],indataftCU,p_R2C,p_C2R,paraMark[9],gaussWidth,printfMark,meanAngularStep,ANG_NUM,realMaskCU,weightingCU);
	printfMark = 0;
	cudaMemcpy(indataD,indataDCU,sizeof(float)*Sx*Sy, cudaMemcpyDeviceToHost);
	//calculate amean amin amax
	for (j = ystart ; j < ystart+outhead->ny ; j++)
		for (i = 0 ; i < Sx ; i++){
			dataT = indataD[j*Sx+i];
			if (dataT > amax)
				amax = dataT;
			if (dataT < amin)
				amin = dataT;
			amean += dataT;
		}
	mrc_add_slice(fout,outhead,indataD+ystart*Sx);

	finishedTask+=1;
        processedNum = (int)(finishedTask/totalTask*100/processFactor);
        for (pp = 0; pp < processedNum; pp++)
                processedcmd[pp] = '.';
        processedcmd[processedNum] = '>';
        for (pp = processedNum+1; pp < 100/processFactor; pp++)
                processedcmd[pp] = ' ';
        processedcmd[pp] = '\0';
        printf("ICONMasked %05.2f%%",finishedTask/totalTask*100);
        printf("  #%s",processedcmd);
        printf("#\r");
        fflush(stdout);
	
    }


    fclose(fout);
    outhead->amean = amean/(outhead->nx*outhead->ny*outhead->nz);
    outhead->amin = amin;
    outhead->amax = amax;
    mrc_replace_head(outfile,outhead);
    mrc_update_rms(outfile);

    
    free(inhead);
    free(outhead);
    free(indataD);
    free(line);
    free(rotline);
    free(origmask);
    free(thita);
    free (paraMark);
    cudaFree(indataDCU);
    cudaFree(origmaskCU);
    cudaFree(indataftCU);
    cudaFree(realMaskCU);
    cudaFree(weightingCU);
    cufftDestroy(p_R2C);
    cufftDestroy(p_C2R);
    free(realMask);
    free(weighting);

    //log Write
    sprintf(loginfo,"running state:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"ICONMask3 finish!\n");
    logwrite(loginfo);
    //end of log Write
}

