#ifndef TEXT_LINE_MAX
#define TEXT_LINE_MAX         800
#endif


#ifndef     PI
#define     PI                3.14159265358979323846
#define     PI_180            0.01745329252
#endif

#define SIZELIMIT 2500

#include <stdio.h>
#include <string.h>
#include <time.h>
#include "fftw3.h"
#include "mrcfile3.h"
#include "../log/log.h"

void help()
{
    printf("ICONMask parameter\n######\n");
    printf("-inputPath (-i) : the folder that contains all 2D reconstructed slices (named midxxxxx.mrc), normally corresponding to the reconstruction folder generated by ICON.\n######\n");
    printf("-tiltfile (-t) : the aligned tilt file.\n######\n");
    printf("-output (-o) : the masked 3D reconstruction.\n######\n");
    printf("-slice (-s) : the reconstructed slices for combination including 2 parts split by ','. For example, 0,511 means that combining 512 slices ranging from slice 0 (mid00000.mrc) to slice 511 (mid00511.mrc).\n######\n");
    printf("-thikness (-th) : the thickness of the final masked 3D reconstruction in pixel.\n######\n");
    printf("-radius (-r) : the mask radius (in pixel) used in the Fourier domain of the combined 3D reconstruction. If this option is used, 'crossVfrc' and 'fullRecfrc' are not used.\n######\n");
    printf("-gaussWidth (-gw) : the gaussian width of the soft mask (in pixel). If '-crossVfrc' & '-fullRecVfrc' are used, the default value is calculated accroding to FRC0.3 - FRC0.5; if '-radius' is used, the default value is 10.\n######\n");
    printf("-crossVfrc (-cf) : the FRC curve from the cross validation process. If 'radius' is used, this option is not used.\n######\n");
    printf("-fullRecfrc (-ff) : the FRC file from the full reconstruction process. If 'radius' is used, this option is not used.\n######\n");
    printf("-zshift (-z) : the shift (in pixel) of sample in Z axis, default as 0.\n#####\n");
    printf("-nomask (-nm) : if this value is set to 0 then a validation filtering mask will be executed; otherwise, no validation filtering mask will be executed, default as 0.\n######\n");
    printf("-blockSize (-bs) : the size of a cube mask; default as 256.\n######\n");
    printf("-help (-h) : for help.\n");
}

void simpleCatch(char *infilePath,int sliceBegin,int sliceEnd,int thickness,char *outfile,int zshift)
{
    char loginfo[1000];
    MrcHeader  *outhead;
    FILE  *fout;
    if((fout=fopen(outfile,"w+"))==NULL)
    {
        printf("\nCannot open file '%s' strike any key exit!",outfile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Cannot open file '%s'\n",outfile);
        logwrite(loginfo);
        //end of log Write
        exit(1);
    }
    outhead=(MrcHeader *)malloc(sizeof(MrcHeader));

    // MRCCatch
    float *indataD;
    //float *indatatmp;
    int nx;
    long ii,j,j1,k;
    int i;
    MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    FILE * infile;
    char filename[1000];
    float finishedTask = 0;
    int processedNum;
    float totalTask = sliceEnd - sliceBegin + 1;
    int processFactor = 5;
    int pp;
    char processedcmd[1000];
    double amean,amin,amax;
    float tmp;
    amean = 0.0;
    amin = 10e10;
    amax = -10e10;
    for (i = sliceBegin ; i <= sliceEnd; i++)
    {
        sprintf(filename,"%s/mid%05d.mrc",infilePath,i);
        if ((infile = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Cannot open infile '%s'\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(infile,inhead);
        if (zshift < 0)
        {
            if (inhead->ny/2-zshift+thickness/2 > inhead->ny)
            {
                printf("zshift & thickness make the size of volume out of limitation!\n");
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"zshift & thickness make the size of volume out of limitation!\n");
                logwrite(loginfo);
                //end of log Write
                exit(0);
            }
        }
        else
        {
            if (inhead->ny/2-zshift-thickness/2 < 0)
            {
                printf("zshift & thickness make the size of volume out of limitation!\n");
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"zshift & thickness make the size of volume out of limitation!\n");
                logwrite(loginfo);
                //end of log Write
                exit(0);
            }
        }
        if (i == sliceBegin)
        {
            //indatatmp = (float *)malloc((long)inhead->nx*(long)inhead->ny*sizeof(float));
            indataD = (float *)malloc((long)inhead->nx*(long)thickness*sizeof(float));
            nx = inhead->nx;
            memcpy(outhead,inhead,sizeof(MrcHeader));
            //mrc_init_head(outhead);
            outhead->nx = nx;
            outhead->ny = thickness;
            outhead->nz = (sliceEnd-sliceBegin+1);
            outhead->mode = MRC_MODE_FLOAT;
            mrc_write_head(fout,outhead);
        }
	long ystart = inhead->ny/2 - thickness/2 + zshift, yend = ystart + thickness;
        //mrc_read_slice(infile,inhead,0,'z',indatatmp);
	mrc_read_slice_in_Z_with_thickness(infile,inhead,0,'z',indataD,ystart,yend);
	//calculate mean, max and min for the final volume.
        for (j = 0; j < yend-ystart ; j++)
        	for (ii = 0 ; ii < nx ; ii++){
			tmp = indataD[j*nx+ii];
			if (tmp > amax)
				amax = tmp;
			if (tmp < amin)
				amin = tmp;
			amean += tmp;
	}
	//end of calculate mean, max and min for the final volume.
        //mrc_add_slice(fout,outhead,indatatmp+ystart*nx);
	mrc_add_slice(fout,outhead,indataD);
        fclose(infile);
        finishedTask+=1;
        processedNum = (int)(finishedTask/totalTask*100/processFactor);
        for (pp = 0; pp < processedNum; pp++)
            processedcmd[pp] = '.';
        processedcmd[processedNum] = '>';
        for (pp = processedNum+1; pp < 100/processFactor; pp++)
            processedcmd[pp] = ' ';
        processedcmd[pp] = '\0';
        printf("simple catched %.2f%%",finishedTask/totalTask*100);
        printf("  #%s",processedcmd);
        printf("#\r");
        fflush(stdout);
    }

    fclose(fout);

    //update output header 
    outhead->amin = amin;
    outhead->amax = amax;
    outhead->amean = amean/outhead->nz/outhead->nx/outhead->ny;
    mrc_replace_head(outfile,outhead);
    mrc_update_rms(outfile);
	
    //mrc_update_head(outfile);

    //free(indatatmp);
    free(indataD);
    free(outhead);
                                                            
    //log Write
    sprintf(loginfo,"running state:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"ICONMask2 simple catch finish!\n");
    logwrite(loginfo);
    //end of log Write
}

void maskVolume(float* indataD,int Psize,float* origmask,float radius05Rate,float radius03Rate,int paraMark3,fftwf_complex* indataft,fftwf_plan *p,fftwf_plan *pinv,int paraMark9,int gaussWidth,int printfMark)
{
    int radius05 = (int)((float)Psize/2.0*radius05Rate);
    int radius03 = (int)((float)Psize/2.0*radius03Rate);
    int nx,ny,nz,i,j,k,i1,j1,k1;
    nx = ny = nz = Psize;

    fftwf_execute(*p);

    double w,w2;
    long nynx = ny*(nx/2+1);

    long gaussianlenMax;
    int radius;
    if (!paraMark3)
    {
        if (!paraMark9)
            gaussianlenMax = radius03-radius05;
        else
            gaussianlenMax = gaussWidth;
        radius = radius05;
    }
    else
    {
        radius = radius05;
        if (!paraMark9)
            gaussianlenMax = 10.0*(Psize/150.0);
        else
            gaussianlenMax = gaussWidth;
    }
    if (gaussianlenMax < 10.0*(Psize/150.0))
        gaussianlenMax = 10.0*(Psize/150.0);

    if (!paraMark9 && printfMark)
        printf("gaussWidth : %ld\n",gaussianlenMax);
    long gaussianradius = (radius + gaussianlenMax);
    long gaussianlen = gaussianradius - radius;

    long rr;
    double xxx,c;
    c = (double)gaussianlen/3.0;
    for (k = 0 ; k < nz ; k++)
        for (j = 0 ; j < ny ; j++)
            for (i = 0 ; i < nx/2+1 ; i++)
            {
                i1 = (i + nx/2)%nx;
                j1 = (j + ny/2)%ny;
                k1 = (k + nz/2)%nz;
                rr = sqrt((i1-nx/2)*(i1-nx/2)+(j1-ny/2)*(j1-ny/2)+(k1-nz/2)*(k1-nz/2));
                if (rr >= radius)
                {
                    if (rr <= gaussianradius)
                    {
                        w = origmask[j1*nx+i1];
                        xxx = rr - radius;
                        w2 = (exp(-(xxx*xxx)/(2*c*c))-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)))/(1-exp(-(gaussianlen)*(gaussianlen)/(2*c*c)));
                        w = w > w2 ? w : w2;
                        indataft[k*nynx+j*(nx/2+1)+i][0] *= w;
                        indataft[k*nynx+j*(nx/2+1)+i][1] *= w;
                    }
                    else
                    {
                        w = origmask[j1*nx+i1];
                        indataft[k*nynx+j*(nx/2+1)+i][0] *= w;
                        indataft[k*nynx+j*(nx/2+1)+i][1] *= w;
                    }
                }
            }

    fftwf_execute(*pinv);

    double factor = (double)nx*(double)ny*(double)nz;
    long len = (long)nx*(long)ny*(long)nz;
    for (i = 0 ; i < len ; i++)
        indataD[i] /= factor;


}


int main(argc,argv)
int argc;
char *argv[];
{
    char infilePath[1000],infile[1000],anglefile[1000],outfile[1000],crossVfrcfile[1000],fullRecfrcfile[1000];
    int radius,radius05,radius03,sliceBegin,sliceEnd,thickness,zshift,gaussWidth,noMask,Psize,Ssize,blockSize;

    int i,j,k,i1,j1,k1;
    char loginfo[1000];
    time_t rawtime;
    struct tm * timeinfo;
    //log Write
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    logwrite("##############################\n");
    sprintf(loginfo,"time:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"%s",asctime(timeinfo));
    logwrite(loginfo);
    sprintf(loginfo,"cmd:\n   ");
    logwrite(loginfo);
    for (i = 0 ; i < argc ; i++)
    {
        sprintf(loginfo,"%s ",argv[i]);
        logwrite(loginfo);
    }
    sprintf(loginfo,"\n");
    logwrite(loginfo);
    //end of log Write


    // read Parameter

    int paraNum = 12;
    int *paraMark = (int *)malloc(paraNum*sizeof(int));
    i = 1;
    memset(paraMark,0,paraNum*sizeof(int));
    zshift = 0;
    radius = 0;
    paraMark[8] = 1;
    noMask = 0;
    blockSize = 256;
    while (i < argc)
    {
        if (argv[i][0] == '-')
        {
            if (strcmp(argv[i]+1,"inputPath") == 0 || strcmp(argv[i]+1,"i") == 0)
            {
                i++;
                sscanf(argv[i],"%s",infilePath);
                i++;
                paraMark[0] = 1;
            }
            else if (strcmp(argv[i]+1,"slice") == 0 || strcmp(argv[i]+1,"s") == 0)
            {
                i++;
                sscanf(argv[i],"%d,%d",&sliceBegin,&sliceEnd);
                i++;
                paraMark[1] = 1;
            }
            else if (strcmp(argv[i]+1,"thickness") == 0 || strcmp(argv[i]+1,"th") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&thickness);
                i++;
                paraMark[2] = 1;
            }
            else if (strcmp(argv[i]+1,"radius") == 0 || strcmp(argv[i]+1,"r") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&radius);
                i++;
                paraMark[3] = 1;
            }
            else if (strcmp(argv[i]+1,"tiltfile") == 0 || strcmp(argv[i]+1,"t") == 0)
            {
                i++;
                sscanf(argv[i],"%s",anglefile);
                i++;
                paraMark[4] = 1;
            }
            else if (strcmp(argv[i]+1,"output") == 0 || strcmp(argv[i]+1,"o") == 0)
            {
                i++;
                sscanf(argv[i],"%s",outfile);
                i++;
                paraMark[5] = 1;
            }
            else if (strcmp(argv[i]+1,"crossVfrc") == 0 || strcmp(argv[i]+1,"cf") == 0)
            {
                i++;
                sscanf(argv[i],"%s",crossVfrcfile);
                i++;
                paraMark[6] = 1;
            }
            else if (strcmp(argv[i]+1,"fullRecfrc") == 0 || strcmp(argv[i]+1,"ff") == 0)
            {
                i++;
                sscanf(argv[i],"%s",fullRecfrcfile);
                i++;
                paraMark[7] = 1;
            }
            else if (strcmp(argv[i]+1,"zshift") == 0 || strcmp(argv[i]+1,"z") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&zshift);
                i++;
                paraMark[8] = 1;
            }
            else if (strcmp(argv[i]+1,"gaussWidth") == 0 || strcmp(argv[i]+1,"gw") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&gaussWidth);
                i++;
                paraMark[9] = 1;
            }
            else if (strcmp(argv[i]+1,"noMask") == 0 || strcmp(argv[i]+1,"nm") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&noMask);
                i++;
                paraMark[10] = 1;
            }
            else if (strcmp(argv[i]+1,"blockSize") == 0 || strcmp(argv[i]+1,"bs") == 0)
            {
                i++;
                sscanf(argv[i],"%d",&blockSize);
                i++;
                paraMark[11] = 1;
            }
            else if (strcmp(argv[i]+1,"help") == 0 || strcmp(argv[i]+1,"h") == 0)
            {
                i++;
                help();
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"ICONMask2 help finish!\n");
                logwrite(loginfo);
                //end of log Write
                return;
            }
            else
                i++;
        }
        else
            i++;
    }

    {
        printf("parameter:\n");
        printf("inputPath : %s\n",infilePath);
        printf("slice : %d,%d\n",sliceBegin,sliceEnd);
        printf("thickness : %d\n",thickness);
        if (paraMark[3])
            printf("radius : %d\n",radius);
        printf("zshift : %d\n",zshift);
        printf("tiltfile : %s\n",anglefile);
        printf("output : %s\n",outfile);
        if (!paraMark[3] && (paraMark[6] && paraMark[7]))
        {
            printf("crossVfrc : %s\n",crossVfrcfile);
            printf("fullRecfrc : %s\n",fullRecfrcfile);
        }
        if (paraMark[9])
            printf("gaussWidth : %d\n",gaussWidth);
        printf("noMask : %d\n",noMask);
    }

    if (!(paraMark[0] && paraMark[1] && paraMark[2] && paraMark[4] && paraMark[5]))
    {
        printf("parameter error!\n'-inputPath' or '-slice' or '-thickness' or '-tiltfile' or '-output' are missed!\nPlease use -help to see the manual\n");
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"parameter error!\n'-inputPath' or '-slice' or '-thickness' or '-tiltfile' or '-output' are missed!\n");
        logwrite(loginfo);
        //end of log Write
        return;
    }

    if (noMask == 1)
    {
        printf("'-noMask' is 1; simple Catch is executed without validation filtering mask!\n");
        simpleCatch(infilePath,sliceBegin,sliceEnd,thickness,outfile,zshift);
        //log write in simpleCatch
        return;
    }

    if (noMask == 0 && !paraMark[3] && !(paraMark[6] && paraMark[7]))
    {
        printf("parameter error!\n'-radius' or ('-crossVfrc' & 'fullRecfrc') are missed!\nPlease use -help to see the manual\n");
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"parameter error!\n'-radius' or ('-crossVfrc' & 'fullRecfrc') are missed!\n");
        logwrite(loginfo);
        //end of log Write
        return;
    }

    //----------------------------------------------------------end of read Parameter

    //read anglefile
    char *lstr, *pch;
    lstr = (char *)malloc(TEXT_LINE_MAX);
    FILE   *fang;
    float *thita;
    thita = (float *)malloc(360*sizeof(float));
    int  ANG_NUM;

    if((fang=fopen(anglefile,"r"))==NULL)
    {
        printf("\nCannot open file %s strike any key exit!\n",anglefile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Can not open file %s!\n",anglefile);
        logwrite(loginfo);
        //end of log Write
        return -1;
    }

    for(i=0; feof(fang)==0;)
    {
        memset(lstr,0,TEXT_LINE_MAX);
        fgets(lstr,TEXT_LINE_MAX,fang);

        pch = strtok(lstr," ;,\n\r\t");

        if(*lstr==EOF||pch == NULL||strncasecmp(pch,"END",3)==0 )break;

        while(pch != NULL)
        {
            thita[i++] = atof(pch);
            pch = strtok(NULL," ;,\n\r\t");
        }

    }
    free(lstr);
    fclose(fang);
    ANG_NUM = i;
    //--------------------------end of read anglefile

    //calculate the biggest angular step and the radius of missing-wedge that can be filled
    float biggestThita = -1;
    float smallestThita = 1;
    float biggestAngularStep;
    int biggestAngularStepRadius;
    for (i = 0 ; i < ANG_NUM ; i++){
 	if (biggestThita < thita[i])
		biggestThita = thita[i];
	if (smallestThita > thita[i])
		smallestThita = thita[i];
    }
    biggestAngularStep = biggestThita - smallestThita;
    biggestAngularStepRadius = ceil(2*180.0/3.1415926/biggestAngularStep);
    //--------------------------end of calculate the biggest angular step and the radius of missing-wedge that can be filled

    int Vx,Vy,Vz;
    int overlapSize = 10;
    //see if can do mask
    {
        MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
        FILE * fin;
        char filename[1000];
        sprintf(filename,"%s/mid%05d.mrc",infilePath,sliceBegin);
        if ((fin = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open infile %s!\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(fin,inhead);
        Vx = inhead->nx;
        Vy = inhead->ny;
        Vz = sliceEnd - sliceBegin + 1;

        Psize = blockSize;
        if (Psize > Vx)
            Psize = Vx;
        if (Psize > Vy)
            Psize = Vy;
        if (Psize > Vz)
            Psize = Vz;
        Ssize = Psize - 2*overlapSize;
        printf("blockSize : %d\n",Psize);
        /*     //ICONMask2 can still run when sliceEnd - sliceBegin + 1 != inhead->nx if the frcFiles are valid.
            if (sliceEnd - sliceBegin + 1 != inhead->nx && !paraMark[3])
            {

                simpleCatch(infilePath,sliceBegin,sliceEnd,thickness,outfile,zshift);
                return;
            }
        */
	fclose(fin);
        free(inhead);
    }

    //calculate the radius of mask
    float radius05Rate,radius03Rate;
    int frcValidMark = 1;
    if (!paraMark[3])
    {
        FILE *fcrossVfrc,*ffullRecfrc;
        if((fcrossVfrc=fopen(crossVfrcfile,"r"))==NULL)
        {
            printf("\nCannot open file '%s' strike any key exit!",crossVfrcfile);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open file %s!\n",crossVfrcfile);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        if((ffullRecfrc=fopen(fullRecfrcfile,"r"))==NULL)
        {
            printf("\nCannot open file '%s' strike any key exit!",fullRecfrcfile);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open file %s!\n",fullRecfrcfile);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        int frcsize = 0;
        float tmp;
        float crossVfrc[10000],fullRecfrc[10000];
        while (fscanf(fcrossVfrc,"%f %f",&tmp,&(crossVfrc[frcsize]))!=EOF)
        {
            frcsize++;
        }
        fclose(fcrossVfrc);
        if (frcsize < Vx/2 - 1)
        {
            printf("'-crossVfrc' %s is not valid\nAssign radius : %d\n",crossVfrcfile,biggestAngularStepRadius);
            paraMark[3] = 1;
	    radius = biggestAngularStepRadius;
	    frcValidMark = 0;
        }
	if (frcValidMark){
            frcsize = 0;
            while (fscanf(ffullRecfrc,"%f %f",&tmp,&(fullRecfrc[frcsize]))!=EOF)
            {
                frcsize++;
            }
            fclose(ffullRecfrc);
            if (frcsize < Vx/2 - 1)
            {
            	printf("'-fullRecfrc' %s is not valid\nAssign radius : %d\n",fullRecfrcfile,biggestAngularStepRadius);
            	paraMark[3] = 1;
	    	radius = biggestAngularStepRadius;
	    	frcValidMark = 0;
            }
	    if (frcValidMark){
            	for (i = 0 ; i < frcsize ; i++)
            		{
            			if (fullRecfrc[i] != 0)
                			crossVfrc[i] /= fullRecfrc[i];
            		}  
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
            		if (crossVfrc[i] >= 0.5)
               			break;
       	    	radius = i;
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
            		if (crossVfrc[i] >= 0.3)
                		break;
            	radius03 = i;
            	//searching from the back
            	for (i = frcsize-1 ; i >= 0 ; i--)
             		if (crossVfrc[i] >= 0.5)
                		break;
            	radius05 = i;
            	printf("the calculated radius of frc0.5 is %d\nthe calculated radius of frc0.3 is %d\n",radius05,radius03);
            	if ((radius05>radius03) || radius03 == 0)
            	{
            		printf("(radius05>radius03) || radius03 == 0 means the frc Files are not valid\nAssign radius : %d\n",biggestAngularStepRadius);
            		paraMark[3] = 1;
	    		radius = biggestAngularStepRadius;
	    		frcValidMark = 0;
            	}
		if (frcValidMark){
            		radius05Rate = (float)radius05/(float)frcsize;
            		radius03Rate = (float)radius03/(float)frcsize;
		}
	    }
    	}
    }
    if (paraMark[3])
    {
        radius05Rate = (float)radius/((float)Vx/2.0);
        radius03Rate = 0;
    }
    //--------------------------end of calculate the radius of mask

    //determine the size of final volume and the start points
    int CVxStart,CVyStart,CVzStart,CVxEnd,CVyEnd,CVzEnd,currentIndex;
    int CVx,CVy,CVz;
    CVxStart = 0;
    CVxEnd = Vx-1;
    CVyStart = Vy/2-thickness/2+zshift;
    if (CVyStart < 0)
        CVyStart = 0;
    CVyEnd = Vy/2 + thickness/2+zshift-1;
    if (CVyEnd > Vy-1)
        CVyEnd = Vy-1;
    CVzStart = sliceBegin;
    CVzEnd = sliceEnd;
    CVx = CVxEnd - CVxStart + 1;
    CVy = CVyEnd - CVyStart + 1;
    CVz = CVzEnd - CVzStart + 1;
    //printf("CVxStart %d CVxEnd %d CVx %d\n",CVxStart,CVxEnd,CVx);
    //printf("CVyStart %d CVyEnd %d CVy %d\n",CVyStart,CVyEnd,CVy);
    //printf("CVzStart %d CVzEnd %d CVz %d\n",CVzStart,CVzEnd,CVz);
    //--------------------------end of determine the size of final volume and the start points

    //determine the CCVSlist and CCVPlist
    //
    int CCVxSlistLen = round(CVx/Ssize)+1;
    int CCVySlistLen = round(CVy/Ssize)+1;
    int CCVzSlistLen = round(CVz/Ssize)+1;

    //CCVS stores the segmentation information based on Ssize and the original volume (nx*ny*nz)
    int *CCVxSStartlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVySStartlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzSStartlist = (int *)malloc(CCVzSlistLen*sizeof(int));
    int *CCVxSEndlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVySEndlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzSEndlist = (int *)malloc(CCVzSlistLen*sizeof(int));

    //CCVP stores the segmentation information based on Psize and the original volume (nx*ny*nz)
    int *CCVxPStartlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVyPStartlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzPStartlist = (int *)malloc(CCVzSlistLen*sizeof(int));
    int *CCVxPEndlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVyPEndlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzPEndlist = (int *)malloc(CCVzSlistLen*sizeof(int));

    //CCVSInP the segmentation information for S in P
    int *CCVxSInPStartlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVySInPStartlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzSInPStartlist = (int *)malloc(CCVzSlistLen*sizeof(int));
    int *CCVxSInPEndlist = (int *)malloc(CCVxSlistLen*sizeof(int));
    int *CCVySInPEndlist = (int *)malloc(CCVySlistLen*sizeof(int));
    int *CCVzSInPEndlist = (int *)malloc(CCVzSlistLen*sizeof(int));

    CCVxSlistLen = 0;
    currentIndex = CVxStart;
    while (currentIndex <= CVxEnd)
    {
        CCVxSStartlist[CCVxSlistLen] = currentIndex;
        CCVxSEndlist[CCVxSlistLen] = CCVxSStartlist[CCVxSlistLen] + Ssize - 1;
        if (CCVxSEndlist[CCVxSlistLen] > CVxEnd)
            CCVxSEndlist[CCVxSlistLen] = CVxEnd;
        currentIndex = CCVxSEndlist[CCVxSlistLen] + 1;
        CCVxSlistLen++;
        //printf("CCVxSStartlist %d CCVxSEndlist %d\n",CCVxSStartlist[CCVxSlistLen-1],CCVxSEndlist[CCVxSlistLen-1]);
    }
    CCVySlistLen = 0;
    currentIndex = CVyStart;
    while (currentIndex <= CVyEnd)
    {
        CCVySStartlist[CCVySlistLen] = currentIndex;
        CCVySEndlist[CCVySlistLen] = CCVySStartlist[CCVySlistLen] + Ssize - 1;
        if (CCVySEndlist[CCVySlistLen] > CVyEnd)
            CCVySEndlist[CCVySlistLen] = CVyEnd;
        currentIndex = CCVySEndlist[CCVySlistLen] + 1;
        CCVySlistLen++;
        //printf("CCVySStartlist %d CCVySEndlist %d\n",CCVySStartlist[CCVySlistLen-1],CCVySEndlist[CCVySlistLen-1]);
    }
    CCVzSlistLen = 0;
    currentIndex = CVzStart;
    while (currentIndex <= CVzEnd)
    {
        CCVzSStartlist[CCVzSlistLen] = currentIndex;
        CCVzSEndlist[CCVzSlistLen] = CCVzSStartlist[CCVzSlistLen] + Ssize - 1;
        if (CCVzSEndlist[CCVzSlistLen] > CVzEnd)
            CCVzSEndlist[CCVzSlistLen] = CVzEnd;
        currentIndex = CCVzSEndlist[CCVzSlistLen] + 1;
        CCVzSlistLen++;
        //printf("CCVzSStartlist %d CCVzSEndlist %d\n",CCVzSStartlist[CCVzSlistLen-1],CCVzSEndlist[CCVzSlistLen-1]);
    }

    int h;
    for (i = 0 ; i < CCVxSlistLen ; i++)
    {
        CCVxPStartlist[i] = (CCVxSEndlist[i]+CCVxSStartlist[i])/2-(Psize/2-1);
        CCVxSInPStartlist[i] = CCVxSStartlist[i] - CCVxPStartlist[i];
        if (CCVxPStartlist[i] < 0)
        {
            h = -CCVxPStartlist[i];
            CCVxPStartlist[i] = 0;
            CCVxSInPStartlist[i] -= h;
        }
        CCVxPEndlist[i] = CCVxPStartlist[i] + Psize - 1;
        if (CCVxPEndlist[i] > (Vx - 1))
        {
            h = CCVxPEndlist[i] - (Vx - 1);
            CCVxPEndlist[i] = (Vx - 1);
            CCVxPStartlist[i] -= h;
            CCVxSInPStartlist[i] += h;
        }
        CCVxSInPEndlist[i] = CCVxSInPStartlist[i] + CCVxSEndlist[i] - CCVxSStartlist[i];
        //printf("CCVxPStartlist %d CCVxPEndlist %d CCVxSInPStartlist %d CCVxSInPEndlist %d\n",CCVxPStartlist[i],CCVxPEndlist[i],CCVxSInPStartlist[i],CCVxSInPEndlist[i]);
    }
    for (i = 0 ; i < CCVySlistLen ; i++)
    {
        CCVyPStartlist[i] = (CCVySEndlist[i]+CCVySStartlist[i])/2-(Psize/2-1);
        CCVySInPStartlist[i] = CCVySStartlist[i] - CCVyPStartlist[i];
        if (CCVyPStartlist[i] < 0)
        {
            h = -CCVyPStartlist[i];
            CCVyPStartlist[i] = 0;
            CCVySInPStartlist[i] -= h;
        }
        CCVyPEndlist[i] = CCVyPStartlist[i] + Psize - 1;
        if (CCVyPEndlist[i] > (Vy - 1))
        {
            h = CCVyPEndlist[i] - (Vy - 1);
            CCVyPEndlist[i] = (Vy - 1);
            CCVyPStartlist[i] -= h;
            CCVySInPStartlist[i] += h;
        }
        CCVySInPEndlist[i] = CCVySInPStartlist[i] + CCVySEndlist[i] - CCVySStartlist[i];
        //printf("CCVyPStartlist %d CCVyPEndlist %d CCVySInPStartlist %d CCVySInPEndlist %d\n",CCVyPStartlist[i],CCVyPEndlist[i],CCVySInPStartlist[i],CCVySInPEndlist[i]);
    }
    for (i = 0 ; i < CCVzSlistLen ; i++)
    {
        CCVzPStartlist[i] = (CCVzSEndlist[i]+CCVzSStartlist[i])/2-(Psize/2-1);
        CCVzSInPStartlist[i] = CCVzSStartlist[i] - CCVzPStartlist[i];
        if (CCVzPStartlist[i] < sliceBegin)
        {
            h = sliceBegin - CCVzPStartlist[i];
            CCVzPStartlist[i] = sliceBegin;
            CCVzSInPStartlist[i] -= h;
        }
        CCVzPEndlist[i] = CCVzPStartlist[i] + Psize - 1;
        if (CCVzPEndlist[i] > sliceEnd)
        {
            h = CCVzPEndlist[i] - sliceEnd;
            CCVzPEndlist[i] = sliceEnd;
            CCVzPStartlist[i] -= h;
            CCVzSInPStartlist[i] += h;
        }
        CCVzSInPEndlist[i] = CCVzSInPStartlist[i] + CCVzSEndlist[i] - CCVzSStartlist[i];
        //printf("CCVzPStartlist %d CCVzPEndlist %d CCVzSInPStartlist %d CCVzSInPEndlist %d\n",CCVzPStartlist[i],CCVzPEndlist[i],CCVzSInPStartlist[i],CCVzSInPEndlist[i]);
    }
    //--------------------------end of determine the CCVSlist and CCVPlist

    //generation of bangbang
    long ny = Psize;
    long nx = Psize;
    float *line = (float *)malloc(nx*ny*sizeof(float));
    float *rotline = (float *)malloc(nx*ny*sizeof(float));
    float *origmask = (float *)malloc(nx*ny*sizeof(float));
    float xf,yf,dx,dy;
    int xi,yi;
    int x,y;
    float costhita,sinthita;
    memset(origmask,0,nx*ny*sizeof(float));
    memset(line,0,nx*ny*sizeof(float));
    for (j = 0 ; j < nx ; j++)
        line[j*nx+nx/2] = 1.0;
    for (k = 0 ; k < ANG_NUM ; k++)
    {
        costhita = cos((-thita[k]-90)*PI_180);
        sinthita = sin((-thita[k]-90)*PI_180);
        memset(rotline,0,nx*ny*sizeof(float));
        for (j = 0 ; j < ny ; j++)
            for (i = 0 ; i < nx ; i++)
            {
                if (line[j*nx+i] != 0)
                {
                    xf = (float)(i-nx/2)*costhita-(float)(j-ny/2)*sinthita+nx/2;
                    yf = (float)(i-nx/2)*sinthita+(float)(j-ny/2)*costhita+ny/2;
                    xi = (int)xf;
                    yi = (int)yf;
                    dx = xf - xi;
                    dy = yf - yi;
                    if (xi >= 0 && xi < nx && yi >=0 && yi <ny)
                        rotline[yi*nx+xi] += line[j*nx+i]*(1-dx)*(1-dy);
                    if (xi >= 0 && xi < nx && yi+1 >=0 && yi+1 <ny)
                        rotline[(yi+1)*nx+xi] += line[j*nx+i]*(1-dx)*dy;
                    if (xi+1 >= 0 && xi+1 < nx && yi >=0 && yi <ny)
                        rotline[yi*nx+xi+1] += line[j*nx+i]*dx*(1-dy);
                    if (xi+1 >= 0 && xi+1 < nx && yi+1 >=0 && yi+1 <ny)
                        rotline[(yi+1)*nx+xi+1] += line[j*nx+i]*dx*dy;
                }
            }
        for (i = 0 ; i < nx*ny ; i++)
        {
            origmask[i] += rotline[i];
        }
    }
    for (i = 0 ; i < nx*ny ; i++)
        if (origmask[i] > 1)
            origmask[i] = 1;

    /*FILE *mf = fopen("mask_128","w+");
    for (i = 0 ; i < nx*ny ; i++)
	fprintf(mf,"%f\n",origmask[i]);
    fclose(mf);*/
	

    //end of generation of bangbang


    //devide and mask
    float *indataD = (float *)malloc(sizeof(float)*Psize*Psize*Psize);
    fftwf_complex* indataft = (fftwf_complex*)fftwf_malloc(sizeof(fftwf_complex)*Psize*Psize*Psize);
    fftwf_plan p = fftwf_plan_dft_r2c_3d(Psize,Psize,Psize,indataD,indataft,FFTW_ESTIMATE);
    fftwf_plan pinv = fftwf_plan_dft_c2r_3d(Psize,Psize,Psize,indataft,indataD,FFTW_ESTIMATE);

    int clipYStart = CCVyPStartlist[0];
    int clipYEnd = CCVyPEndlist[CCVySlistLen-1]+1;
    int clipYSize = clipYEnd - clipYStart;
    float *clipVolume = (float*)malloc(Vx*clipYSize*Psize*sizeof(float));

    int saveYStart = CCVySStartlist[0];
    int saveYEnd = CCVySEndlist[CCVySlistLen-1]+1;
    int saveYSize = saveYEnd - saveYStart; 
    float *saveVolume = (float *)malloc(Vx*saveYSize*Ssize*sizeof(float));

    MrcHeader * inhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    MrcHeader * outhead=(MrcHeader *)malloc(sizeof(MrcHeader));
    FILE * fin,*fout;
    if((fout=fopen(outfile,"w+"))==NULL)
    {
        printf("\nCannot open file '%s' strike any key exit!",outfile);
        //log Write
        sprintf(loginfo,"running state:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"fail!\n");
        logwrite(loginfo);
        sprintf(loginfo,"Error message:\n   ");
        logwrite(loginfo);
        sprintf(loginfo,"Can not open file %s!\n",outfile);
        logwrite(loginfo);
        //end of log Write
        exit(1);
    }
    {
        char filename[1000];
        sprintf(filename,"%s/mid%05d.mrc",infilePath,sliceBegin);
        if ((fin = fopen(filename,"r")) == NULL)
        {
            printf("\nCan not open infile %s!\n",filename);
            //log Write
            sprintf(loginfo,"running state:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"fail!\n");
            logwrite(loginfo);
            sprintf(loginfo,"Error message:\n   ");
            logwrite(loginfo);
            sprintf(loginfo,"Can not open infile %s!\n",filename);
            logwrite(loginfo);
            //end of log Write
            exit(1);
        }
        mrc_read_head(fin,inhead);
        fclose(fin);
    }
    memcpy(outhead,inhead,sizeof(MrcHeader));
    outhead->nx = CVx;
    outhead->nz = CVz;
    outhead->ny = CVy;
    outhead->mode = MRC_MODE_FLOAT;
    mrc_write_head(fout,outhead);

    char filename[1000];
    int Psize2 = Psize*Psize;
    int VxClipYSize = Vx*clipYSize;
    int VxSaveYSize = Vx*saveYSize;
    int CVxCVy = CVx*CVy;
    int z;
    double amean = 0;
    double amin = 10e10;
    double amax = -10e10;
    float totalTask = CCVzSlistLen*CCVySlistLen*CCVxSlistLen;
    float finishedTask = 0;
    char processedcmd[1000];
    int processedNum,pp,processFactor;
    int printfMark = 1;
    float dataT;
    processFactor = 5;
     
    for (z = 0 ; z < CCVzSlistLen ; z++){
	//time(&rawtime);
	//timeinfo = localtime(&rawtime);
	//printf("reading data begins at %s",asctime(timeinfo));
        for (k1 = CCVzPStartlist[z], k = 0 ; k1 <= CCVzPEndlist[z] ; k1++,k++)
        {
            sprintf(filename,"%s/mid%05d.mrc",infilePath,k1);
            if ((fin = fopen(filename,"r")) == NULL)
            {
                printf("\nCan not open infile %s!\n",filename);
                //log Write
                sprintf(loginfo,"running state:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"fail!\n");
                logwrite(loginfo);
                sprintf(loginfo,"Error message:\n   ");
                logwrite(loginfo);
                sprintf(loginfo,"Can not open infile %s!\n",filename);
                logwrite(loginfo);
                //end of log Write
                exit(1);
            }
            mrc_read_head(fin,inhead);
            mrc_read_slice_in_Z_with_thickness(fin,inhead,0,'z',clipVolume+k*VxClipYSize,clipYStart,clipYEnd);
            fclose(fin);
        }
	//time(&rawtime);
	//timeinfo = localtime(&rawtime);
	//printf("reading data ends at %s",asctime(timeinfo)); 
	//time(&rawtime);
	//timeinfo = localtime(&rawtime);
	//printf("masking data begins at %s",asctime(timeinfo)); 
        for (y = 0 ; y < CCVySlistLen ; y++)
        {
            for (x = 0 ; x < CCVxSlistLen ; x++)
            {
                for (k1 = CCVzPStartlist[z], k = 0 ; k1 <= CCVzPEndlist[z] ; k1++,k++)
                    for (j1 = CCVyPStartlist[y]-CCVyPStartlist[0],j = 0 ; j1 <= CCVyPEndlist[y]-CCVyPStartlist[0] ; j1++,j++)
                        for (i1 = CCVxPStartlist[x],i = 0 ; i1 <= CCVxPEndlist[x] ; i1++,i++)
                            indataD[k*Psize2+j*Psize+i] = clipVolume[k*VxClipYSize+j1*Vx+i1];
                maskVolume(indataD,Psize,origmask,radius05Rate,radius03Rate,paraMark[3],indataft,&p,&pinv,paraMark[9],gaussWidth,printfMark);
		printfMark = 0;

		//put the masked volume into saveVolume
		//calculate amean amin amax
		for (k1 = CCVzSInPStartlist[z], k = 0 ; k1 <= CCVzSInPEndlist[z] ; k1++,k++)
                    for (j1 = CCVySInPStartlist[y],j = CCVySStartlist[y]-CCVySStartlist[0] ; j1 <= CCVySInPEndlist[y]; j1++,j++)
                        for (i1 = CCVxSInPStartlist[x],i = CCVxSStartlist[x] ; i1 <= CCVxSInPEndlist[x] ; i1++,i++){
			    dataT = indataD[k1*Psize2+j1*Psize+i1];
			    if (dataT > amax)
				amax = dataT;
			    if (dataT < amin)
				amin = dataT;
			    amean += dataT;
                            saveVolume[k*VxSaveYSize+j*Vx+i] = dataT;
			}
		finishedTask+=1;
                processedNum = (int)(finishedTask/totalTask*100/processFactor);
                for (pp = 0; pp < processedNum; pp++)
                    processedcmd[pp] = '.';
            processedcmd[processedNum] = '>';
            for (pp = processedNum+1; pp < 100/processFactor; pp++)
                    processedcmd[pp] = ' ';
            processedcmd[pp] = '\0';
            printf("ICONMasked %05.2f%%",finishedTask/totalTask*100);
            printf("  #%s",processedcmd);
            printf("#\r");
            fflush(stdout);
	    }
        }
	
	//write saveVolume into disk
	for (k1 = CCVzSInPStartlist[z], k = 0 ; k1 <= CCVzSInPEndlist[z] ; k1++,k++)
		mrc_add_slice(fout,outhead,saveVolume+k*VxSaveYSize);
    }


    fclose(fout);
    outhead->amean = amean/(outhead->nx*outhead->ny*outhead->nz);
    outhead->amin = amin;
    outhead->amax = amax;
    mrc_replace_head(outfile,outhead);
    mrc_update_rms(outfile);

    free(CCVxSStartlist);
    free(CCVySStartlist);
    free(CCVzSStartlist);
    free(CCVxSEndlist);
    free(CCVySEndlist);
    free(CCVzSEndlist);
    free(CCVxPStartlist);
    free(CCVyPStartlist);
    free(CCVzPStartlist);
    free(CCVxPEndlist);
    free(CCVyPEndlist);
    free(CCVzPEndlist);
    free(CCVxSInPStartlist);
    free(CCVySInPStartlist);
    free(CCVzSInPStartlist);
    free(CCVxSInPEndlist);
    free(CCVySInPEndlist);
    free(CCVzSInPEndlist);
    free(inhead);
    free(outhead);
    fftwf_destroy_plan(p);
    fftwf_destroy_plan(pinv);
    fftwf_free(indataft);
    free(clipVolume);
    free(saveVolume);
    free(indataD);
    free(line);
    free(rotline);
    free(origmask);
    free(thita);
    free (paraMark);

    //log Write
    sprintf(loginfo,"running state:\n   ");
    logwrite(loginfo);
    sprintf(loginfo,"ICONMask2 finish!\n");
    logwrite(loginfo);
    //end of log Write
}

